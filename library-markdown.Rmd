---
title: "libraries-analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)
```



```{r data load, echo=FALSE}
#loading libraries
library(rvest)
library(stringr)
library(purrr)
library(plyr)
library(shiny)
library(dplyr)
library(lubridate)
library(leaflet)
library(sf)
library(sp)
library(ggplot2)

#loading base website
base_website <- "https://www.data.brisbane.qld.gov.au/data/dataset/library-checkouts-branch-date"

#extracting links with library checkout data
urls <- read_html(base_website) %>%
  html_nodes("a") %>%
  html_attr("href") %>%
  str_subset("\\.zip") %>%
  as.list()

#extracting url link with acronym data
acronym_url <- read_html(base_website) %>%
  html_nodes("a") %>%
  html_attr("href") %>%
  str_subset("\\.csv$") 

#after reading in file, it was found colnames are not same across files (have minor differences)
# as some are separated with a "." and others are not
#reading in initial dataframe and applying col names to each df so when appending there are no issues

#reading in initial file column names
temp_file <- tempfile()
#downloading file to a temp location
col_name_file <- download.file(url = urls[[1]],temp_file)
#unzipping file to get a csv
csv_col_name_df <- unzip(temp_file, list = T)
#reading csv and getting colnames from file
csv_col_names <- colnames(read.csv(unz(temp_file,csv_col_name_df$Name)))


#creating a function to download and read data from each zipped url file & apply same colnames to each file
test_function <- function (download_url) {
  #creating tempfile for url to download 
  temp <- tempfile()
  
  # downloading urls
  download.file(url = download_url, temp)
  
  #unzipping listed files
  list.files <- unzip(temp,list=TRUE)
  
  #reading unzipped listed files
  data <- read.csv(unz(temp,list.files$Name[1]))
  
  #applying same colnames to each df
  colnames(data) <- csv_col_names
  
  #returning the dataframe read in
  return(data)
  
}

#creating list of dataframes from each downloaded file
test <- map(urls,test_function)

#appending all library records into one dataframe
dataframe <- ldply(test, rbind)

#cleaning checkout df to have dates in useful format etc.
checkouts <- dataframe %>%
  mutate(Datetime = as_datetime(
    paste0(str_sub(Date, 1,4),
           "-", 
           str_sub(Date,5,6),
           "-", 
           str_sub(Date,7,8),
           " ",
           str_sub(Date,9,10),
           ":",
           str_sub(Date,11,12),
           ":",
           str_sub(Date,13,14)),
    format = "%Y-%m-%d %H:%M:%S"),
    Date = as_date(Datetime))

#reading in acronym url data
acronym_df <- read.csv(acronym_url)

#splitting acronum url data into 3 data sets for easier use later on
#branch split
branch_df <- acronym_df[,1:2] %>%
  #removing all blank rows
  filter(Branch.Code!= "") %>%
  add_row(Branch.Code = "KEN", Branch.Heading = "Kenmore")

#heading split
heading_df <- acronym_df[,4:5] %>%
  #removing all blank rows
  filter(Heading != "")


#loading library locations dataset
library_locations <- read.csv("https://www.data.brisbane.qld.gov.au/data/dataset/6fc6ea2a-46d5-4339-a4b9-0f63ce5cfac4/resource/0f223803-897b-46e3-8fbb-930ad1925673/download/brisbane-city-council-libraries-information-dec-2020.csv") %>% 
  #adding a name variable to make it easier to join to other datasets without a branch code
  mutate(name = gsub("Library", "", Venue)) %>%
  #converting the long & lat to coords for easier plotting
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326)

```

### Choose a Tab {.tabset .tabset-fade .tabset-dropdown}
#### Map of libraries across Brisbane

```{r library_map, echo=FALSE, message=FALSE, warning=FALSE}
#creating a book icon for the map markers of libraries
iconSet <- awesomeIconList(
  library = makeAwesomeIcon(
    icon = 'book',
    library = 'fa',
    iconColor = 'gold',
    markerColor = 'blue',
    spin = F)
)

#plotting libraries on map
leaflet() %>%
  addProviderTiles("Stamen.TonerLite", group = "Base") %>%
  addProviderTiles(providers$OpenStreetMap, group = "Street map") %>%
  addAwesomeMarkers(data = library_locations,
                    label = library_locations$Venue,
                    icon = ~iconSet,
                    group = "libraries") %>%
  addLayersControl(baseGroups = c("Street map","Base"),
                   overlayGroups = c("libraries"),
                   options = layersControlOptions(collapsed = FALSE)) %>%
  hideGroup(c("libraries"))

```

#### Number of borrowed books
```{r borrowed books, echo=FALSE}
checkouts_grouped <- checkouts %>%
  inner_join(branch_df, by = c("Checkout.Library" = "Branch.Code")) %>%
  #only missing library branch code is LHQ which i am unable to ascertain what this library is
  group_by(Branch.Heading, Age) %>%
  summarise(count = n()) %>%
  filter(Age %in% c("ADULT","JUVENILE","YA"))
  

ggplot(data = checkouts_grouped) +
  geom_col(aes(fill = Age, y = count, x = Branch.Heading),
           position = "stack", show.legend = T)+
  theme_classic()+
  labs(x = "BCC Library Branch",
       y = "Number of books borrowed",
       title = "Number of books borrowed from each library by age category")+
  theme(axis.text.x = element_text(angle = 45, hjust = 0.95, size = 7))
```



```{r reactable table, eval=FALSE, include=FALSE}
library(reactable)
library(crosstalk)
library(tidyr)

checkouts_grouped_month_year <- checkouts %>%
  inner_join(branch_df, by = c("Checkout.Library" = "Branch.Code")) %>%
  #only missing library branch code is LHQ which i am unable to ascertain what this library is
  group_by(Branch.Heading, format(Date, "%Y/%m")) %>%
  summarise(count = n(),
            Date = format(Date, "%Y/%m")) %>%
  unique() %>%
  arrange(Date,
          -count) %>%
  ungroup() %>%
  group_by(Date)%>%
  top_n(n = 3, wt = count) %>%
  spread(Branch.Heading, count)


#creating a colour pallette to help show the scale of numbers
bcc_pal <- function(x) rgb(colorRamp(c("#006bb7","gold"))(x),maxColorValue = 255)

shared_data <- SharedData$new(checkouts_grouped_month_year)
#outtbl <-
  reactable(
    shared_data,
    searchable = T,
    filterable = T,
    columns = list(
      antecedents = colDef(show = T),
      consequents = colDef(show = T),
      antecedent_support= colDef(show = T,
                                   format = colFormat(suffix = "%", separators = F)),
      consequent_support= colDef(show = T,
                                   format = colFormat(suffix = "%", separators = F)),
      support = colDef(
        style = function(value) {
          normalised <- (value-min(apriori_data$support))/(max(apriori_data$support)-min(apriori_data$support))
          color <- orange_pal(normalised)
          list(background = color)
        },
        format = colFormat(suffix = " checkouts", separators = F)
      ),
      #hiding the individual comments columns
      Comments_1 = colDef(show = F),
      Comments_2 = colDef(show = F),
      Comments_3 = colDef(show = F),
      Comments_4 = colDef(show = F),
      Comments_5 = colDef(show = F),
      Details = colDef(
        name = "Comments",
        sortable = F,
        cell = function() htmltools::tags$button("Show comments"))
      ),
    #making the table be sorted by lift by default
    defaultSorted = "lift",
    defaultSortOrder = "desc",
    resizable = T,
    wrap = T,
    bordered = T,
    elementId = "apriori-table",
    #combining all comments into a single popup when button is clicked
    onClick = JS("function(rowInfo,colInfo) {
                 // Only handle events on the details column
                 if (colInfo.id !== 'Details') {
                 return
                 }
                 // Display an alert dialog with details for the row
                 window.alert(JSON.stringify(rowInfo.row['Comments_1'],null,1) +
                 '\\n' + '\\n' +
                 JSON.stringify(rowInfo.row['Comments_2'],null,1) +
                 '\\n' + '\\n' +
                  JSON.stringify(rowInfo.row['Comments_3'],null,1) +
                  '\\n' +'\\n' +
                  JSON.stringify(rowInfo.row['Comments_4'],null,1) +
                  '\\n' + '\\n' +
                  JSON.stringify(rowInfo.row['Comments_5'],null,1))
                 }")
  )
outtbl




```

